<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h4 class="heading"><span class="type">Paragraph</span></h4>
<div class="para"> Although we will not consider this in detail, these algorithms are usually applied to <em class="emphasis">weighted</em> graphs.  Here every edge has some weight or cost assigned to it.  The goal is to find a spanning tree that has the smallest possible combined weight.  Such a tree is called a <dfn class="terminology">minimum spanning tree</dfn>.  Finding the minimum spanning tree uses basically the same algorithms as we described above, but when picking an edge to add, you always pick the smallest (or when removing an edge, you always remove the largest).<details class="ptx-footnote" aria-live="polite" id="sec_trees-5-10-5"><summary class="ptx-footnote__number" title="Footnote 2.6"><sup> 6 </sup></summary><div class="ptx-footnote__contents" id="sec_trees-5-10-5"> If you add the smallest edge adjacent to edges you have already added, you are doing <em class="emphasis">Prim’s algorithm</em>.  If you add the smallest edge in the entire graph, you are following <em class="emphasis">Kruskal’s algorithm</em>.</div></details>
</div>
<span class="incontext"><a class="internal" href="sec_trees.html#sec_trees-5-10">in-context</a></span>
</body>
</html>
